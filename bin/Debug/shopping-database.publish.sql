/*
Deployment script for Shopping

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "Shopping"
:setvar DefaultFilePrefix "Shopping"
:setvar DefaultDataPath "G:\LargeDatabases\Data\"
:setvar DefaultLogPath "G:\LargeDatabases\Logs\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [$(DatabaseName)];


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS ON,
                ANSI_PADDING ON,
                ANSI_WARNINGS ON,
                ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                QUOTED_IDENTIFIER ON,
                ANSI_NULL_DEFAULT ON,
                CURSOR_DEFAULT LOCAL,
                RECOVERY FULL 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET PAGE_VERIFY NONE 
            WITH ROLLBACK IMMEDIATE;
    END


GO
PRINT N'Creating Schema [admin]...';


GO
CREATE SCHEMA [admin]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [data]...';


GO
CREATE SCHEMA [data]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating Schema [internal]...';


GO
CREATE SCHEMA [internal]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating User-Defined Table Type [dbo].[UdtId]...';


GO
CREATE TYPE [dbo].[UdtId] AS TABLE (
    [Id] INT NULL);


GO
PRINT N'Creating Table [admin].[StaticDataStatements]...';


GO
CREATE TABLE [admin].[StaticDataStatements] (
    [StaticDataId] INT            NOT NULL,
    [Statement]    NVARCHAR (MAX) NOT NULL,
    CONSTRAINT [PKStaticDataStatements] PRIMARY KEY CLUSTERED ([StaticDataId] ASC)
);


GO
PRINT N'Creating Table [admin].[StaticDataDependencies]...';


GO
CREATE TABLE [admin].[StaticDataDependencies] (
    [StaticDataId] INT       NOT NULL,
    [FunctionName] [sysname] NOT NULL,
    CONSTRAINT [PKStaticDataDependencies] PRIMARY KEY CLUSTERED ([StaticDataId] ASC, [FunctionName] ASC)
);


GO
PRINT N'Creating Table [admin].[StaticData]...';


GO
CREATE TABLE [admin].[StaticData] (
    [StaticDataId] INT       NOT NULL,
    [SchemaName]   [sysname] NOT NULL,
    [TableName]    [sysname] NOT NULL,
    [Precedence]   TINYINT   NOT NULL,
    [IsTestData]   BIT       NOT NULL,
    CONSTRAINT [PK_static_data] PRIMARY KEY CLUSTERED ([StaticDataId] ASC)
);


GO
PRINT N'Creating Table [dbo].[BarCode]...';


GO
CREATE TABLE [dbo].[BarCode] (
    [BarCodeId] INT            IDENTITY (1, 1) NOT NULL,
    [BarCode]   NVARCHAR (255) NOT NULL,
    [ProductId] INT            NOT NULL,
    CONSTRAINT [PKBarCodeBarCodeId] PRIMARY KEY CLUSTERED ([BarCodeId] ASC)
);


GO
PRINT N'Creating Table [dbo].[Category]...';


GO
CREATE TABLE [dbo].[Category] (
    [CategoryId] INT            NOT NULL,
    [Name]       NVARCHAR (255) NOT NULL,
    CONSTRAINT [PKCategoryCategoryId] PRIMARY KEY CLUSTERED ([CategoryId] ASC)
);


GO
PRINT N'Creating Table [dbo].[Product]...';


GO
CREATE TABLE [dbo].[Product] (
    [ProductId] INT            IDENTITY (1, 1) NOT NULL,
    [Name]      NVARCHAR (255) NOT NULL,
    CONSTRAINT [PKProductProductId] PRIMARY KEY CLUSTERED ([ProductId] ASC)
);


GO
PRINT N'Creating Table [dbo].[ProductCategory]...';


GO
CREATE TABLE [dbo].[ProductCategory] (
    [ProductId]  INT NOT NULL,
    [CategoryId] INT NOT NULL,
    CONSTRAINT [PKProductCategoryProductIdCategoryId] PRIMARY KEY CLUSTERED ([ProductId] ASC, [CategoryId] ASC)
);


GO
PRINT N'Creating Table [dbo].[ProductSuperMarket]...';


GO
CREATE TABLE [dbo].[ProductSuperMarket] (
    [ProductId]     INT NOT NULL,
    [SuperMarketId] INT NOT NULL,
    [AisleNumber]   INT NULL,
    CONSTRAINT [PKProductSuperMarketProductIdSuperMarketId] PRIMARY KEY CLUSTERED ([ProductId] ASC, [SuperMarketId] ASC)
);


GO
PRINT N'Creating Table [dbo].[Settings]...';


GO
CREATE TABLE [dbo].[Settings] (
    [SettingId] INT            IDENTITY (1, 1) NOT NULL,
    [Name]      NVARCHAR (50)  NOT NULL,
    [Value]     NVARCHAR (500) NULL,
    CONSTRAINT [PK_settings_name] PRIMARY KEY CLUSTERED ([Name] ASC)
);


GO
PRINT N'Creating Index [dbo].[Settings].[UXSettingsName]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [UXSettingsName]
    ON [dbo].[Settings]([Name] ASC)
    INCLUDE([Value]);


GO
PRINT N'Creating Table [dbo].[ShoppingList]...';


GO
CREATE TABLE [dbo].[ShoppingList] (
    [ShoppingListId] INT      IDENTITY (1, 1) NOT NULL,
    [SuperMarketId]  INT      NOT NULL,
    [DateCreated]    DATETIME NOT NULL,
    [DateModified]   DATETIME NOT NULL,
    CONSTRAINT [PKShoppingList] PRIMARY KEY CLUSTERED ([ShoppingListId] ASC)
);


GO
PRINT N'Creating Table [dbo].[ShoppingListProduct]...';


GO
CREATE TABLE [dbo].[ShoppingListProduct] (
    [ShoppingListProductId] INT      IDENTITY (1, 1) NOT NULL,
    [ShoppingListId]        INT      NOT NULL,
    [ProductId]             INT      NOT NULL,
    [DateCreated]           DATETIME NOT NULL,
    [DateModified]          DATETIME NOT NULL,
    CONSTRAINT [PKShoppingListProduct] PRIMARY KEY CLUSTERED ([ShoppingListProductId] ASC)
);


GO
PRINT N'Creating Table [dbo].[SuperMarket]...';


GO
CREATE TABLE [dbo].[SuperMarket] (
    [SuperMarketId] INT            NOT NULL,
    [Name]          NVARCHAR (255) NOT NULL,
    CONSTRAINT [PKSuperMarkeSuperMarkeId] PRIMARY KEY CLUSTERED ([SuperMarketId] ASC)
);


GO
PRINT N'Creating Default Constraint [admin].[DFStaticDataIsTestData]...';


GO
ALTER TABLE [admin].[StaticData]
    ADD CONSTRAINT [DFStaticDataIsTestData] DEFAULT (0) FOR [IsTestData];


GO
PRINT N'Creating Default Constraint [dbo].[DF_ShoppingList_DateCreated]...';


GO
ALTER TABLE [dbo].[ShoppingList]
    ADD CONSTRAINT [DF_ShoppingList_DateCreated] DEFAULT (GETDATE()) FOR [DateCreated];


GO
PRINT N'Creating Default Constraint [dbo].[DF_ShoppingList_[DateModified]...';


GO
ALTER TABLE [dbo].[ShoppingList]
    ADD CONSTRAINT [DF_ShoppingList_[DateModified] DEFAULT (GETDATE()) FOR [DateModified];


GO
PRINT N'Creating Default Constraint [dbo].[DF_ShoppingListProduct_DateCreated]...';


GO
ALTER TABLE [dbo].[ShoppingListProduct]
    ADD CONSTRAINT [DF_ShoppingListProduct_DateCreated] DEFAULT (GETDATE()) FOR [DateCreated];


GO
PRINT N'Creating Default Constraint [dbo].[DF_ShoppingListProduct_[DateModified]...';


GO
ALTER TABLE [dbo].[ShoppingListProduct]
    ADD CONSTRAINT [DF_ShoppingListProduct_[DateModified] DEFAULT (GETDATE()) FOR [DateModified];


GO
PRINT N'Creating Foreign Key [admin].[FKStaticDataStatementsStaticDataId]...';


GO
ALTER TABLE [admin].[StaticDataStatements] WITH NOCHECK
    ADD CONSTRAINT [FKStaticDataStatementsStaticDataId] FOREIGN KEY ([StaticDataId]) REFERENCES [admin].[StaticData] ([StaticDataId]) ON DELETE CASCADE;


GO
PRINT N'Creating Foreign Key [dbo].[FKBarCodeProductId]...';


GO
ALTER TABLE [dbo].[BarCode] WITH NOCHECK
    ADD CONSTRAINT [FKBarCodeProductId] FOREIGN KEY ([ProductId]) REFERENCES [dbo].[Product] ([ProductId]) ON DELETE CASCADE;


GO
PRINT N'Creating Foreign Key [dbo].[FKProductCategoryProductId]...';


GO
ALTER TABLE [dbo].[ProductCategory] WITH NOCHECK
    ADD CONSTRAINT [FKProductCategoryProductId] FOREIGN KEY ([ProductId]) REFERENCES [dbo].[Product] ([ProductId]) ON DELETE CASCADE;


GO
PRINT N'Creating Foreign Key [dbo].[FKProductCategoryCategoryId]...';


GO
ALTER TABLE [dbo].[ProductCategory] WITH NOCHECK
    ADD CONSTRAINT [FKProductCategoryCategoryId] FOREIGN KEY ([CategoryId]) REFERENCES [dbo].[Category] ([CategoryId]) ON DELETE CASCADE;


GO
PRINT N'Creating Foreign Key [dbo].[FKProductSuperMarketProductId]...';


GO
ALTER TABLE [dbo].[ProductSuperMarket] WITH NOCHECK
    ADD CONSTRAINT [FKProductSuperMarketProductId] FOREIGN KEY ([ProductId]) REFERENCES [dbo].[Product] ([ProductId]) ON DELETE CASCADE;


GO
PRINT N'Creating Foreign Key [dbo].[FKProductSuperMarketSuperMarketId]...';


GO
ALTER TABLE [dbo].[ProductSuperMarket] WITH NOCHECK
    ADD CONSTRAINT [FKProductSuperMarketSuperMarketId] FOREIGN KEY ([SuperMarketId]) REFERENCES [dbo].[SuperMarket] ([SuperMarketId]) ON DELETE CASCADE;


GO
PRINT N'Creating Foreign Key [dbo].[FKShoppingListSuperMarketId]...';


GO
ALTER TABLE [dbo].[ShoppingList] WITH NOCHECK
    ADD CONSTRAINT [FKShoppingListSuperMarketId] FOREIGN KEY ([SuperMarketId]) REFERENCES [dbo].[SuperMarket] ([SuperMarketId]) ON DELETE CASCADE;


GO
PRINT N'Creating Foreign Key [dbo].[FKShoppingListProductShoppingListId]...';


GO
ALTER TABLE [dbo].[ShoppingListProduct] WITH NOCHECK
    ADD CONSTRAINT [FKShoppingListProductShoppingListId] FOREIGN KEY ([ShoppingListId]) REFERENCES [dbo].[ShoppingList] ([ShoppingListId]) ON DELETE CASCADE;


GO
PRINT N'Creating Foreign Key [dbo].[FKShoppingListProductProductId]...';


GO
ALTER TABLE [dbo].[ShoppingListProduct] WITH NOCHECK
    ADD CONSTRAINT [FKShoppingListProductProductId] FOREIGN KEY ([ProductId]) REFERENCES [dbo].[Product] ([ProductId]) ON DELETE CASCADE;


GO
PRINT N'Creating Function [internal].[GetSetting]...';


GO
CREATE FUNCTION [internal].[GetSetting]
(
	@Name	NVARCHAR(50)
)
RETURNS NVARCHAR(500)
AS
BEGIN
	RETURN
		(
			SELECT
						s.[Value] 
				FROM	[dbo].[Settings] s
				WHERE	s.[Name] = @Name
		)
END
GO
PRINT N'Creating Function [internal].[GetPopulateSetting]...';


GO
CREATE FUNCTION [internal].[GetPopulateSetting]
(
)
RETURNS DATETIME2
AS
BEGIN
	RETURN
		(
			SELECT CONVERT(DATETIME2,[internal].[GetSetting](N'Populate'))
		)
END
GO
PRINT N'Creating Function [internal].[FormatErrorMessage]...';


GO
CREATE FUNCTION [internal].[FormatErrorMessage]
(
	  @errmsg								NVARCHAR(2048)
	, @severity								INT	
	, @state								INT
	, @errno								INT
	, @errproc								SYSNAME
	, @lineno								INT
	, @proc									SYSNAME
)
RETURNS NVARCHAR(2048)
AS
BEGIN
	RETURN
		(
			CASE 
				WHEN @errmsg LIKE CONVERT(NVARCHAR(2048),'***%')                                     
					THEN '*** ' + COALESCE(QUOTENAME(@proc), '<dynamic SQL>') + ', Line ' + LTRIM(STR(@lineno)) + '. Errno ' + LTRIM(STR(@errno)) + ': ' + CHAR(10) + @errmsg
				ELSE '*** ' + COALESCE(QUOTENAME(@errproc), QUOTENAME(@proc), '<dynamic SQL>') + ', Line ' + LTRIM(STR(@lineno)) + '. Errno ' + LTRIM(STR(@errno)) + ': ' + @errmsg
			END
		)
END
GO
PRINT N'Creating Function [internal].[ExtendedPropertyExists]...';


GO
CREATE FUNCTION [internal].[ExtendedPropertyExists]
(
	  @ObjectName		SYSNAME
	, @PropertyName		SYSNAME
	, @ColumnName		SYSNAME
)
RETURNS BIT
AS
BEGIN
	RETURN
		(
			CASE 
				WHEN EXISTS
						(
							SELECT	1 
							FROM	[sys].[extended_properties] ep
							WHERE	ep.[major_id] = OBJECT_ID(@ObjectName)
							 AND	ep.[name] = @PropertyName
							 AND	( ( @ColumnName IS NULL
									AND	ep.[minor_id] = 0
									  )
								OR	  ep.[minor_id] = 
										(
											SELECT	sc.[colid]
											FROM	[sys].[syscolumns] sc
											WHERE	sc.[id] = ep.[major_id]
											 AND	sc.[name] = @ColumnName
										)
									)
						)
					THEN 1
				ELSE 0
			END	
		)
END
GO
PRINT N'Creating Function [internal].[IndexExists]...';


GO
CREATE FUNCTION [internal].[IndexExists]
(
	  @ObjectName	SYSNAME
	, @IndexName	SYSNAME
)
RETURNS BIT
AS
BEGIN
	RETURN
		(
			CASE 
				WHEN INDEXPROPERTY(OBJECT_ID(@ObjectName),@IndexName,'IndexID') IS NOT NULL
					THEN 1
				ELSE 0
			END	
		)
END
GO
PRINT N'Creating Function [internal].[ColumnExists]...';


GO
CREATE FUNCTION [internal].[ColumnExists]
(
	  @ObjectName	SYSNAME
	, @ColumnName	SYSNAME
)
RETURNS BIT
AS
BEGIN
	RETURN
		(
			CASE 
				WHEN EXISTS
						(
							SELECT	1 
							FROM	[sys].[syscolumns]
							WHERE	[name] = @ColumnName 
							 AND	[id] = OBJECT_ID(@ObjectName)
						)
					THEN 1
				ELSE 0
			END	
		)
END
GO
PRINT N'Creating Function [internal].[UdfGetObjectName]...';


GO
CREATE FUNCTION [internal].[UdfGetObjectName]
(
	  @SchemaName		SYSNAME
	, @TableName		SYSNAME
)
RETURNS SYSNAME
AS
BEGIN
	RETURN
		(
			SELECT ISNULL('[' + @SchemaName + '].[','[') + @TableName + ']'
		)
END
GO
PRINT N'Creating Function [data].[UdfPopulateSuperMarkets]...';


GO
CREATE FUNCTION [data].[UdfPopulateSuperMarkets]
(
	@SuperMarketId INT
)
RETURNS TABLE AS RETURN
(
	SELECT
			  [SuperMarketId]
			, [Name]
	FROM	(
				VALUES
					  (1 , 'PAKnSave')
					, (2 , 'New World')
					, (3 , 'Countdown')
			) AS Source 
			(
				  [SuperMarketId]
				, [Name]
			)
	WHERE	[SuperMarketId] = ISNULL(@SuperMarketId,[SuperMarketId])
)
GO
PRINT N'Creating Function [data].[UdfPopulateCategories]...';


GO
CREATE FUNCTION [data].[UdfPopulateCategories]
(
	@CategoryId INT
)
RETURNS TABLE AS RETURN
(
	SELECT
			  [CategoryId]
			, [Name]
	FROM	(
				VALUES
					  (1 , 'Fruit and Vege')
					, (2 , 'Butchery')
					, (3 , 'Seafood')
					, (4 , 'Deli')
					, (5 , 'Bakery')
					, (6 , 'Dairy and Eggs')
					, (7 , 'Desserts')
					, (8 , 'Frozen Foods')
					, (9 , 'Baking')
					, (10, 'Breakfast Cereals')
					, (11, 'Canned Vege')
					, (12, 'Canned Fruit')
					, (13, 'Canned Other')
					, (14, 'Sauces and Dressings')
					, (15, 'Confectionary')
					, (16, 'Drinks')
					, (17, 'Jams and Spreads')
					, (18, 'Pasta, Rice and Noodles')
					, (19, 'Salad and Cooking Oils')
					, (20, 'Snack Foods')
					, (21, 'Spices and Seasonings')
					, (22, 'Alcohol')
					, (23, 'Oral Health')
					, (24, 'Deoderants')
					, (25, 'Hair Care')
					, (26, 'Face and Lip Care')
					, (27, 'Suncare')
					, (28, 'Cleaning')
					, (29, 'Outdoor')
					, (30, 'Laundry')
			) AS Source 
			(
				  [CategoryId]
				, [Name]
			)
	WHERE	[CategoryId] = ISNULL(@CategoryId,[CategoryId])
)
GO
PRINT N'Creating Function [internal].[UdfGetStaticDataStatement]...';


GO
CREATE FUNCTION [internal].[UdfGetStaticDataStatement]
(
	  @SchemaName	SYSNAME
	, @TableName	SYSNAME
)
RETURNS TABLE AS RETURN
(
	SELECT
			  sds.[Statement]
	FROM	[Admin].[StaticData] sd
			INNER JOIN [Admin].[StaticDataStatements] sds
				ON	sds.[StaticDataId] = sd.[StaticDataId]
	WHERE	sd.[SchemaName] = ISNULL(@SchemaName,sd.[SchemaName])
	 AND	sd.[TableName] = ISNULL(@TableName,sd.[TableName])
)
GO
PRINT N'Creating Function [internal].[GetModifiedCode]...';


GO
CREATE FUNCTION [internal].[GetModifiedCode]
(
)
RETURNS TABLE AS RETURN
(
	SELECT	
				  s.[name] AS [SchemaName]
				, o.[name] AS [ObjectName]
				, o.[type]
				, o.[create_date]
				, o.[modify_date]
		FROM	[sys].[objects] o
				INNER JOIN [sys].[schemas] s
					ON	s.[schema_id] = o.[schema_id]
		WHERE	o.[type] in ( 'FN' , 'FS', 'FT', 'IF' , 'P', 'PC', 'TA', 'TF', 'TR', 'X' )
)
GO
PRINT N'Creating Function [internal].[SplitObjectName]...';


GO
CREATE FUNCTION [internal].[SplitObjectName]
(
	  @ObjectName	SYSNAME
)
RETURNS TABLE AS RETURN
(
	SELECT
				  [SchemaName] = 
					CASE
						WHEN CHARINDEX('[', sch.[SchemaName]) > 0
							THEN SUBSTRING(sch.[SchemaName],2,LEN(sch.[SchemaName]) - 2)
						ELSE sch.[SchemaName]
					END
				, [ObjectName] =
					CASE
						WHEN CHARINDEX('[', obj.[ObjectName]) > 0
							THEN SUBSTRING(obj.[ObjectName],2,LEN(obj.[ObjectName]) - 2)
						ELSE obj.[ObjectName]
					END	
		FROM	(
					SELECT [ObjectName] = REPLACE(LTRIM(RTRIM(@ObjectName)),'''','')
				) clean
				CROSS APPLY
				(
					SELECT	[SchemaName] =
								CASE
									WHEN CHARINDEX('.', clean.[ObjectName]) > 0
										THEN SUBSTRING(clean.[ObjectName],1,CHARINDEX('.', clean.[ObjectName]) - 1)
									ELSE NULL
								END
				) sch
				CROSS APPLY
				(
					SELECT	[ObjectName] =
								CASE
									WHEN CHARINDEX('.', clean.[ObjectName]) > 0
										THEN SUBSTRING(clean.[ObjectName],CHARINDEX('.', clean.[ObjectName]) + 1,LEN(clean.[ObjectName]))
									ELSE clean.[ObjectName]
								END
				) obj
)
GO
PRINT N'Creating Function [internal].[TypeExists]...';


GO
CREATE FUNCTION [internal].[TypeExists]
(
	  @ObjectName	SYSNAME
)
RETURNS BIT
AS
BEGIN
	RETURN
		(
			CASE 
				WHEN EXISTS
						(
							SELECT	1 
							FROM	[internal].[SplitObjectName](@ObjectName) n
									INNER JOIN [sys].[schemas] s
										ON	s.[name] = n.[SchemaName]
									INNER JOIN [sys].[types] t
										ON	t.[name] = n.[ObjectName] 
										AND	t.[schema_id] = s.[schema_id]
							WHERE	[is_table_type] = 1
							 AND	[is_user_defined] = 1
						)
					THEN 1
				ELSE 0
			END	
		)
END
GO
PRINT N'Creating Function [internal].[ObjectExists]...';


GO
CREATE FUNCTION [internal].[ObjectExists]
(
	  @ObjectName	SYSNAME
	, @ObjectType	SYSNAME
)
RETURNS BIT
AS
BEGIN
	RETURN
		(
			CASE 
				WHEN @ObjectType = 'TR' AND (SELECT @@VERSION) LIKE '%SQL Server 2008%'
					THEN
						CASE 
							WHEN EXISTS
									(
										SELECT	1 
										FROM	[internal].[SplitObjectName](@ObjectName) n
												INNER JOIN [sys].[triggers] t
													ON	t.[name] = n.[ObjectName]
									)
								THEN 1
							ELSE 0
						END	
				WHEN OBJECT_ID(@ObjectName,@ObjectType) IS NOT NULL
					THEN 1
				ELSE 0
			END	
		)
END
GO
PRINT N'Creating Procedure [internal].[CatchHandler]...';


GO
CREATE PROCEDURE [internal].[CatchHandler]
	  @proc_id								INT					= NULL
	, @reraise								BIT					= 1
	, @errno								INT					= NULL	OUTPUT
	, @errmsg								NVARCHAR(2048)		= NULL	OUTPUT
	, @errmsg_augmented						NVARCHAR(2048)		= NULL	OUTPUT
AS 
BEGIN
	BEGIN TRY
		--! Reduce unnecessary network traffic and force rollback and aborting upon any error.
		SET NOCOUNT ON
		SET XACT_ABORT ON

		--! Locals.
		DECLARE @me							SYSNAME				= OBJECT_SCHEMA_NAME(@proc_id) + '.' + OBJECT_NAME(@proc_id)					
		DECLARE @crlf						NCHAR(2)			= CHAR(13) + CHAR(10)
		DECLARE @msg						NVARCHAR(2048)
		DECLARE @severity					INT
		DECLARE @state						INT
		DECLARE @proc						SYSNAME
		DECLARE @errproc					SYSNAME
		DECLARE @lineno						INT
	           
	   --! Rollback if transaction in progress.
	   IF @@trancount > 0 ROLLBACK TRANSACTION

		SELECT	  @msg = ERROR_MESSAGE()
				, @severity = ERROR_SEVERITY()
				, @state  = ERROR_STATE()
				, @errno = ERROR_NUMBER()
				, @errproc = ERROR_PROCEDURE()
				, @lineno = ERROR_LINE()

		SELECT @proc = OBJECT_SCHEMA_NAME(@proc_id) + N'.' + OBJECT_NAME(@proc_id)
		SELECT @errmsg = @msg
		SELECT @errmsg_augmented = [internal].[FormatErrorMessage](@msg,@severity,@state,@errno,@errproc,@lineno,@proc)
	       
	END TRY

	BEGIN CATCH
	   --! Hopefully, this never occurs, but if it does, we try to produce both messages. 
	   SELECT @reraise = 1
	   SELECT @msg = @me + ERROR_MESSAGE() + @crlf + 'Original message: ' + @msg

	   --! Set ouptut variables if this has not been done.
	   IF @errmsg IS NULL SELECT @errmsg = @msg
	   IF @errmsg_augmented IS NULL SELECT @errmsg_augmented = @msg

	   -- Avoid new error if transaction is doomed.
	   IF xact_state() = -1 ROLLBACK TRANSACTION
	END CATCH

	--! Reaise if requested (or if an unexepected error occurred).
	IF @reraise = 1
		BEGIN
		   --! Adjust severity if needed; plain users cannot raise level 19.
		   IF @severity > 18 SELECT @severity = 18

		   --! Pass the message as a parameter to a parameter marker to avoid that
		   --! % chars cause problems.
		   RAISERROR('%s', @severity, @state, @errmsg_augmented)
		END
END
GO
PRINT N'Creating Procedure [internal].[LongPrint]...';


GO
CREATE PROCEDURE [internal].[LongPrint]
	  @string								NVARCHAR(MAX)
AS
BEGIN
	BEGIN TRY
		--! Reduce unnecessary network traffic and force rollback and aborting upon any error.
		SET NOCOUNT ON
		SET XACT_ABORT ON

		--! Locals.
		DECLARE @entry_tran_count			INT					= @@TRANCOUNT
		DECLARE @me							NVARCHAR(50)		= OBJECT_SCHEMA_NAME(@@PROCID) + '.' + OBJECT_NAME(@@PROCID)				
		DECLARE @current_end				BIGINT								--! track the length of the next substring
		DECLARE @offset						TINYINT								--! tracks the amount of offset needed

		SET @string = REPLACE(REPLACE(@string, CHAR(13) + CHAR(10), CHAR(10)) , CHAR(13), CHAR(10))

		WHILE LEN(@string) > 1 
			BEGIN
				IF CHARINDEX(CHAR(10), @string) BETWEEN 1 AND 4000
					BEGIN
						SET @current_end = CHARINDEX(CHAR(10), @string) - 1
						SET @offset = 2
					END
				ELSE
					BEGIN
						SET @current_end = 4000
						SET @offset = 1
					END   
 
				PRINT SUBSTRING(@string, 1, @current_end) 
 
				SET @string = SUBSTRING(@string, @current_end+@offset, 1073741822)   
			END
	END TRY

	BEGIN CATCH
		IF @@trancount > 0 ROLLBACK TRANSACTION
		EXEC [internal].[CatchHandler] @@PROCID
		RETURN 55555
	END CATCH
END
GO
PRINT N'Creating Procedure [internal].[SetSetting]...';


GO
CREATE PROCEDURE [internal].[SetSetting]
	  @name									NVARCHAR(50)
	, @value								NVARCHAR(500)
	, @return_code							INT				= NULL	OUT
AS 
BEGIN
	--! Set output parameters.
	SET @return_code = 0

	BEGIN TRY
		--! Reduce unnecessary network traffic and force rollback and aborting upon any error.
		SET NOCOUNT ON
		SET XACT_ABORT ON

		--! Save requested setting.
		UPDATE s
			SET		value = @value
			FROM	[dbo].[Settings] s
			WHERE	s.[name] = @name

		--! Insert if not present.
		IF @@ROWCOUNT < 1
			BEGIN
				INSERT INTO [dbo].[settings]
					(
							  [name]
							, [value]
					)
					VALUES
					(
							  @name
							, @value
					)
			END

		--! Return success.
		RETURN 0
	END TRY

	BEGIN CATCH
		IF @@trancount > 0 ROLLBACK TRANSACTION
		EXEC [internal].[catch_handler] @@PROCID
		RETURN 55555
	END CATCH
END
GO
PRINT N'Creating Procedure [dbo].[AddProductsToShoppingList]...';


GO
CREATE PROCEDURE [dbo].[AddProductsToShoppingList]
	  @ShoppingListId		INT
	, @Products				[dbo].[UdtId]	READONLY
	, @ReturnCode			INT		= NULL	OUT
AS
BEGIN
	--! Set output parameters.
	SET @ReturnCode = 0

	BEGIN TRY
		--! Reduce unnecessary network traffic and force rollback and aborting upon any error.
		SET NOCOUNT ON
		SET XACT_ABORT ON

		--! Locals.
		DECLARE @EntryTranCount				INT					= @@TRANCOUNT
		DECLARE @now						DATETIME			= GETDATE()

		IF @EntryTranCount = 0 
			BEGIN TRANSACTION

		INSERT [dbo].[ShoppingListProduct]
			(
				  [ShoppingListId]
				, [ProductId]
				, [DateCreated]
				, [DateModified]
			)
			SELECT
					  @ShoppingListId
					, p.Id
					, @now
					, @now
			FROM	@Products p
			WHERE	NOT EXISTS
					(
						SELECT	1
						FROM	[dbo].[ShoppingListProduct] slp
						WHERE	slp = p.[Id]
						AND		slp.[ShoppingListId] = @ShoppingListId
					)

		--! If we started the transaction then commit otherwise leave to caller.			
		IF @EntryTranCount = 0 
			COMMIT

		--! Return success.
		RETURN 0
	END TRY

	BEGIN CATCH
		IF @@trancount > 0 ROLLBACK TRANSACTION
		EXEC [internal].[catchhandler] @proc_id = @@PROCID
		RETURN 55555
	END CATCH
END
GO
PRINT N'Creating Procedure [dbo].[CreateShoppingList]...';


GO
CREATE PROCEDURE [dbo].[CreateShoppingList]
	  @SuperMarketId		INT
	, @ShoppingListId		INT		= NULL	OUT
	, @ReturnCode			INT		= NULL	OUT
AS
BEGIN
	--! Set output parameters.
	SET @ShoppingListId = @ShoppingListId
	SET @ReturnCode = 0

	BEGIN TRY
		--! Reduce unnecessary network traffic and force rollback and aborting upon any error.
		SET NOCOUNT ON
		SET XACT_ABORT ON

		--! Locals.
		DECLARE @EntryTranCount				INT					= @@TRANCOUNT
		DECLARE @now						DATETIME			= GETDATE()

		IF @EntryTranCount = 0 
			BEGIN TRANSACTION

		INSERT [dbo].[ShoppingList]
			(
				  [SuperMarketId]
				, [DateCreated]
				, [DateModified]
			)
			VALUES
			(
				  @SuperMarketId
				, @now
				, @now
			)

		SET @ShoppingListId = SCOPE_IDENTITY

		--! If we started the transaction then commit otherwise leave to caller.			
		IF @EntryTranCount = 0 
			COMMIT

		--! Return success.
		RETURN 0
	END TRY

	BEGIN CATCH
		IF @@trancount > 0 ROLLBACK TRANSACTION
		EXEC [internal].[catchhandler] @proc_id = @@PROCID
		RETURN 55555
	END CATCH
END
GO
PRINT N'Creating Procedure [dbo].[GetCategories]...';


GO
CREATE PROCEDURE [dbo].[GetCategories]
	  @CategoryId			INT
	, @ReturnCode			INT		= NULL	OUT
AS
BEGIN
	--! Set output parameters.
	SET @ReturnCode = 0

	BEGIN TRY
		--! Reduce unnecessary network traffic and force rollback and aborting upon any error.
		SET NOCOUNT ON
		SET XACT_ABORT ON

		SELECT	  p.[CategoryId]
				, [Name]
		FROM	[dbo].[Category] p

		--! Return success.
		RETURN 0
	END TRY

	BEGIN CATCH
		IF @@trancount > 0 ROLLBACK TRANSACTION
		EXEC [internal].[catchhandler] @proc_id = @@PROCID
		RETURN 55555
	END CATCH
END
GO
PRINT N'Creating Procedure [dbo].[GetProduct]...';


GO
CREATE PROCEDURE [dbo].[GetProduct]
	  @ProductId			INT
	, @ReturnCode			INT		= NULL	OUT
AS
BEGIN
	--! Set output parameters.
	SET @ReturnCode = 0

	BEGIN TRY
		--! Reduce unnecessary network traffic and force rollback and aborting upon any error.
		SET NOCOUNT ON
		SET XACT_ABORT ON

		SELECT	  [ProductId]
				, [Name]
		FROM	[dbo].[Product]
		WHERE	[ProductId] = @ProductId

		--! Return success.
		RETURN 0
	END TRY

	BEGIN CATCH
		IF @@trancount > 0 ROLLBACK TRANSACTION
		EXEC [internal].[catchhandler] @proc_id = @@PROCID
		RETURN 55555
	END CATCH
END
GO
PRINT N'Creating Procedure [dbo].[GetProducts]...';


GO
CREATE PROCEDURE [dbo].[GetProducts]
	@ReturnCode			INT		= NULL	OUT
AS
BEGIN
	--! Set output parameters.
	SET @ReturnCode = 0

	BEGIN TRY
		--! Reduce unnecessary network traffic and force rollback and aborting upon any error.
		SET NOCOUNT ON
		SET XACT_ABORT ON

		SELECT	  [ProductId]
				, [Name]
		FROM	[dbo].[Product]

		--! Return success.
		RETURN 0
	END TRY

	BEGIN CATCH
		IF @@trancount > 0 ROLLBACK TRANSACTION
		EXEC [internal].[catchhandler] @proc_id = @@PROCID
		RETURN 55555
	END CATCH
END
GO
PRINT N'Creating Procedure [dbo].[GetProductsForCategory]...';


GO
CREATE PROCEDURE [dbo].[GetProductsForCategory]
	  @CategoryId			INT
	, @ReturnCode			INT		= NULL	OUT
AS
BEGIN
	--! Set output parameters.
	SET @ReturnCode = 0

	BEGIN TRY
		--! Reduce unnecessary network traffic and force rollback and aborting upon any error.
		SET NOCOUNT ON
		SET XACT_ABORT ON

		SELECT	  P.[ProductId]
				, [Name]
		FROM	[dbo].[Product] p
				INNER JOIN dbo.[ProductCategory] pc
					ON p.[ProductId] = pc.[ProductId]
		WHERE	pc.[CategoryId] = @CategoryId

		--! Return success.
		RETURN 0
	END TRY

	BEGIN CATCH
		IF @@trancount > 0 ROLLBACK TRANSACTION
		EXEC [internal].[catchhandler] @proc_id = @@PROCID
		RETURN 55555
	END CATCH
END
GO
PRINT N'Creating Procedure [dbo].[GetShoppingListProducts]...';


GO
CREATE PROCEDURE [dbo].[GetShoppingListProducts]
	  @ShoppingListId		INT
	, @ReturnCode			INT		= NULL	OUT
AS
BEGIN
	--! Set output parameters.
	SET @ReturnCode = 0

	BEGIN TRY
		--! Reduce unnecessary network traffic and force rollback and aborting upon any error.
		SET NOCOUNT ON
		SET XACT_ABORT ON

		SELECT	  P.[ProductId]
				, P.[Name]
				, [AisleNumber]
		FROM	[dbo].[ShoppingListProduct] slp
				INNER JOIN [dbo].[Product] p
					ON slp.[ProductId] = p.[ProductId]
				INNER JOIN [dbo].[ShoppingList] sl
					ON sl.[ShoppingListId] = slp.[ShoppingListId]
				INNER JOIN [dbo].[ProductSuperMarket] psm
					ON psm.[SuperMarketId] = sl.[SuperMarketId]
					AND	psm.[ProductId] = p.[ProductId]
		WHERE	slp.[ShoppingListId] = @ShoppingListId
		ORDER BY [AisleNumber]

		--! Return success.
		RETURN 0
	END TRY

	BEGIN CATCH
		IF @@trancount > 0 ROLLBACK TRANSACTION
		EXEC [internal].[CatchHandler] @proc_id = @@PROCID
		RETURN 55555
	END CATCH
END
GO
PRINT N'Creating Procedure [dbo].[GetSuperMarkets]...';


GO
CREATE PROCEDURE [dbo].[GetSuperMarkets]
	@ReturnCode			INT		= NULL	OUT
AS
BEGIN
	--! Set output parameters.
	SET @ReturnCode = 0

	BEGIN TRY
		--! Reduce unnecessary network traffic and force rollback and aborting upon any error.
		SET NOCOUNT ON
		SET XACT_ABORT ON

		SELECT	  [SuperMarketId]
				, [Name]
		FROM	[dbo].[SuperMarket]

		--! Return success.
		RETURN 0
	END TRY

	BEGIN CATCH
		IF @@trancount > 0 ROLLBACK TRANSACTION
		EXEC [internal].[catchhandler] @proc_id = @@PROCID
		RETURN 55555
	END CATCH
END
GO
PRINT N'Creating Procedure [admin].[ApplyStaticData]...';


GO
CREATE PROCEDURE [admin].[ApplyStaticData]
	  @SchemaName							SYSNAME
	, @TableName							SYSNAME
	, @PrintCommands						BIT					= 0			--! values: 0=do not print sql, 1=print sql
	, @PrintCommandsOnly					BIT					= 0			--! values: 0=execute, 1=print only
	, @ReturnCode							INT					= NULL	OUT
AS
BEGIN
	--! Set output parameters now to avoid build issues.
	SET @ReturnCode = 0

	BEGIN TRY
		--! Reduce unnecessary network traffic and force rollback and aborting upon any error.
		SET NOCOUNT ON
		SET XACT_ABORT ON

		--! Locals.
		DECLARE @entry_tran_count			INT					= @@TRANCOUNT
		DECLARE @sql						NVARCHAR(MAX)
		DECLARE @params						NVARCHAR(MAX)		= N'@site_id SMALLINT, @environment_id SMALLINT'

		--! Ensure have required parameters.
		IF @SchemaName IS NULL OR @TableName IS NULL 
			BEGIN
				SET @ReturnCode = -1
				RETURN @ReturnCode
			END

		--! Retrieve information to facilitate building of merge statement.
		SELECT
					@sql = sds.[Statement]
			FROM	[internal].[UdfGetStaticDataStatement](@SchemaName,@TableName) sds

		--! Ensure match found.
		IF @@ROWCOUNT <> 1
			BEGIN
				SET @ReturnCode = -3
				RETURN @ReturnCode
			END

		--! Start transaction unless one already exists.
		IF @entry_tran_count = 0
			BEGIN TRANSACTION

		--! Display and/or execute statement based on parameter.
		PRINT 'Populating table ' + [internal].[UdfGetObjectName](@SchemaName,@TableName)

		IF @PrintCommands = 1
			EXEC [internal].[LongPrint] @String = @sql

		IF @PrintCommandsOnly = 0
			EXEC sp_executesql @sql, @params

		--! If we started the transaction then commit, unless in debug mode, otherwise leave to caller.			
		IF @entry_tran_count = 0
			COMMIT TRANSACTION

		--! Return success.
		RETURN 0
	END TRY

	BEGIN CATCH
		IF @@trancount > 0 ROLLBACK TRANSACTION
		EXEC [internal].[CatchHandler] @proc_id = @@PROCID
		RETURN 55555
	END CATCH
END
GO
PRINT N'Creating Procedure [data].[PopulateStaticDataStatements]...';


GO
CREATE PROCEDURE [data].[PopulateStaticDataStatements]
	  @return_code							INT					= NULL	OUT
AS
BEGIN
	--! Set output parameters now to avoid build issues.
	SET @return_code = 0

	BEGIN TRY
		--! Reduce unnecessary network traffic and force rollback and aborting upon any error.
		SET NOCOUNT ON
		SET XACT_ABORT ON

		--! Locals.
		DECLARE @entry_tran_count			INT					= @@TRANCOUNT

		--! Start transaction unless one already exists.
		IF @entry_tran_count = 0 
			BEGIN TRANSACTION

		MERGE INTO [admin].[StaticDataStatements] AS Target
			USING
				(
					VALUES
						  (100 , '
									MERGE INTO [dbo].[SuperMarket] AS Target
										USING
										(
											SELECT	
													  [SuperMarketId]
													, [Name]
											FROM	[data].[UdfPopulateSuperMarkets](NULL)
										) AS Source 
										ON
											(
													Target.[SuperMarketId] = Source.[SuperMarketId]
											)
										WHEN NOT MATCHED BY TARGET THEN
											INSERT
											(
													  [SuperMarketId]
													, [Name]
											)
											VALUES
											(
													  Source.[SuperMarketId]
													, Source.[Name]
											)
										WHEN MATCHED THEN
											UPDATE
											SET
													  [Name] = Source.[Name]
										;
						  ')
						, (200 , '
									MERGE INTO [dbo].[Category] AS Target
										USING
										(
											SELECT	
													  [CategoryId]
													, [Name]
											FROM	[data].[UdfPopulateCategories](NULL)
										) AS Source 
										ON
											(
													Target.[CategoryId] = Source.[CategoryId]
											)
										WHEN NOT MATCHED BY TARGET THEN
											INSERT
											(
													  [CategoryId]
													, [Name]
											)
											VALUES
											(
													  Source.[CategoryId]
													, Source.[Name]
											)
										WHEN MATCHED THEN
											UPDATE
											SET
													  [Name] = Source.[Name]
										;
						') 
				) AS Source 
				(
						  [StaticDataId]
						, [Statement]
				)
			ON
				(
						Target.[StaticDataId] = Source.[StaticDataId]
				)
			WHEN NOT MATCHED BY TARGET THEN
				INSERT
				(
						  [StaticDataId]
						, [Statement]
				)
				VALUES
				(
						  Source.[StaticDataId]
						, Source.[Statement]
				)
			WHEN MATCHED THEN
				UPDATE 
					SET        
						  [Statement] = Source.[Statement]
			WHEN NOT MATCHED BY SOURCE THEN
				DELETE
			;

		--! If we started the transaction then commit otherwise leave to caller.			
		IF @entry_tran_count = 0 
			COMMIT
		
		--! Return success.
		RETURN 0
	END TRY

	BEGIN CATCH
		IF @@trancount > 0 ROLLBACK TRANSACTION
		EXEC [internal].[CatchHandler] @proc_id = @@PROCID
		RETURN 55555
	END CATCH
END
GO
PRINT N'Creating Procedure [data].[PopulateStaticDataDependencies]...';


GO
CREATE PROCEDURE [data].[PopulateStaticDataDependencies]
	  @return_code							INT					= NULL	OUT
AS
BEGIN
	--! Set output parameters now to avoid build issues.
	SET @return_code = 0

	BEGIN TRY
		--! Reduce unnecessary network traffic and force rollback and aborting upon any error.
		SET NOCOUNT ON
		SET XACT_ABORT ON

		--! Locals.
		DECLARE @entry_tran_count			INT					= @@TRANCOUNT

		--! Start transaction unless one already exists.
		IF @entry_tran_count = 0 
			BEGIN TRANSACTION

		MERGE INTO [admin].[StaticDataDependencies] AS Target
			USING
				(
					VALUES
						  (100 , '[data].[UdfPopulateSuperMarkets]')
						, (200 , '[data].[UdfPopulateCategories]') 
				) AS Source 
				(
						  [StaticDataId]
						, [FunctionName]
				)
			ON
				(
						Target.[StaticDataId] = Source.[StaticDataId]
					AND	Target.[FunctionName] = Source.[FunctionName]
				)
			WHEN NOT MATCHED BY TARGET THEN
				INSERT
				(
						  [StaticDataId]
						, [FunctionName]
				)
				VALUES
				(
						  Source.[StaticDataId]
						, Source.[FunctionName]
				)
			WHEN NOT MATCHED BY SOURCE THEN
				DELETE
			;

		--! If we started the transaction then commit otherwise leave to caller.			
		IF @entry_tran_count = 0 
			COMMIT
		
		--! Return success.
		RETURN 0
	END TRY

	BEGIN CATCH
		IF @@trancount > 0 ROLLBACK TRANSACTION
		EXEC [internal].[CatchHandler] @proc_id = @@PROCID
		RETURN 55555
	END CATCH
END
GO
PRINT N'Creating Procedure [data].[PopulateStaticData]...';


GO
CREATE PROCEDURE [data].[PopulateStaticData]
	  @return_code							INT					= NULL	OUT
AS
BEGIN
	--! Set output parameters now to avoid build issues.
	SET @return_code = 0

	BEGIN TRY
		--! Reduce unnecessary network traffic and force rollback and aborting upon any error.
		SET NOCOUNT ON
		SET XACT_ABORT ON

		--! Locals.
		DECLARE @entry_tran_count			INT					= @@TRANCOUNT

		--! Start transaction unless one already exists.
		IF @entry_tran_count = 0 
			BEGIN TRANSACTION

		MERGE INTO [admin].[StaticData] AS Target
			USING
				(
					VALUES
						  (100 , 'dbo', 'SuperMarket', 10, 0)
						, (200 , 'dbo', 'Category ' , 10, 0) 
				) AS Source 
				(
						  [StaticDataId]
						, [SchemaName]
						, [TableName]
						, [Precedence]
						, [IsTestData]
				)
			ON
				(
						Target.[StaticDataId] = Source.[StaticDataId]
				)
			WHEN NOT MATCHED BY TARGET THEN
				INSERT
				(
						  [StaticDataId]
						, [SchemaName]
						, [TableName]
						, [Precedence]
						, [IsTestData]
				)
				VALUES
				(
						  Source.[StaticDataId]
						, Source.[SchemaName]
						, Source.[TableName]
						, Source.[Precedence]
						, Source.[IsTestData]
				)
			WHEN MATCHED AND 
				(	
					SELECT	HASHBYTES
								(
									  'SHA1' 
									, (	
										SELECT	  
												  Source.[SchemaName]
												, Source.[TableName]
												, Source.[Precedence]
												, Source.[IsTestData]
										FOR XML RAW
									  )
								)
				) <>
				(	
					SELECT	HASHBYTES
								(
									  'SHA1' 
									, (	
										SELECT	  
												  Target.[SchemaName]
												, Target.[TableName]
												, Target.[Precedence]
												, Target.[IsTestData]
										FOR XML RAW
									  )
								)
				) THEN 
				UPDATE 
					SET        
						  [SchemaName] = Source.[SchemaName]
						, [TableName] = Source.[TableName]
						, [Precedence] = Source.[Precedence]
						, [IsTestData] = Source.[IsTestData]
			WHEN NOT MATCHED BY SOURCE THEN
				DELETE
			;

		--! If we started the transaction then commit otherwise leave to caller.			
		IF @entry_tran_count = 0 
			COMMIT
		
		--! Return success.
		RETURN 0
	END TRY

	BEGIN CATCH
		IF @@trancount > 0 ROLLBACK TRANSACTION
		EXEC [internal].[CatchHandler] @proc_id = @@PROCID
		RETURN 55555
	END CATCH
END
GO
PRINT N'Creating Procedure [admin].[PopulateStaticDatas]...';


GO
CREATE PROCEDURE [admin].[PopulateStaticDatas]
	  @ChangesOnly			BIT					= 1			--! true only apply modified data changes and false to populate everything
	, @ChangePeriod			INT					= 1			--! number of hours to consider changed
	, @TestDataOnly			BIT					= 0			--! trune to apply test data only
	, @StaticDataId			INT					= NULL		--! execute specific table only
	, @PrintCommands		BIT					= 0			--! values: 0=do not print sql, 1=print sql
	, @PrintCommandsOnly	BIT					= 0			--! values: 0=execute, 1=print only
	, @ReturnCode			INT					= NULL	OUT
AS
BEGIN
	--! Set output parameters now to avoid build issues.
	SET @ReturnCode = 0

	BEGIN TRY
		--! Reduce unnecessary network traffic and force rollback and aborting upon any error.
		SET NOCOUNT ON
		SET XACT_ABORT ON

		--! Locals.
		DECLARE @EntryTranCount			INT					= @@TRANCOUNT
		DECLARE @SchemaName				SYSNAME
		DECLARE @TableName					SYSNAME
		DECLARE @Sql						NVARCHAR(MAX)
		DECLARE @Params						NVARCHAR(MAX)
		DECLARE @Now						DATETIME2			= GETDATE()	--! Needs to be system rather than local time.
		DECLARE @LastPopulateTime			DATETIME2			= [internal].[GetPopulateSetting]()
		DECLARE @procedure					SYSNAME
		DECLARE @tables						TABLE
			(
				  [SchemaName]				SYSNAME
				, [TableName]				SYSNAME
				, [Precedence]				TINYINT
			)

		--! Set change period to number of hours earlier.
		SET @LastPopulateTime = ISNULL(@LastPopulateTime,DATEADD(HOUR,ISNULL(@ChangePeriod,1) * -1,@Now))

		--! Start transaction unless one already exists.
		IF @EntryTranCount = 0 
			BEGIN TRANSACTION

		EXEC [data].[PopulateStaticData]
		EXEC [data].[PopulateStaticDataStatements]
		EXEC [data].[PopulateStaticDataDependencies]

		--! Execute all or modified data in precence order.
		--! Do not deploy test data to production environments.
		IF @StaticDataId IS NOT NULL
			BEGIN
				INSERT INTO @tables
					(
							  [SchemaName]
							, [TableName]
							, [precedence]
					)
					SELECT	
							  sd.[SchemaName]
							, sd.[TableName]
							, sd.[Precedence]
					FROM	[admin].[StaticData] sd
					WHERE	sd.[StaticDataId] = @StaticDataId
					 AND	[IsTestData] = 0 
			END
		ELSE
			BEGIN
				INSERT INTO @tables
					(
							  [SchemaName]
							, [TableName]
							, [Precedence]
					)
					SELECT	
							  sd.[SchemaName]
							, sd.[TableName]
							, sd.[Precedence]
					FROM	[admin].[StaticData] sd
					WHERE	( @ChangesOnly = 0
						OR	  EXISTS
								(
									SELECT	1
									FROM	[admin].[StaticDataDependencies] sdd
											CROSS APPLY [internal].[SplitObjectName](sdd.[FunctionName]) pn
											INNER JOIN [internal].[GetModifiedCode]() mc
												ON	mc.[SchemaName] = pn.[SchemaName]
												AND	mc.[ObjectName] = pn.[ObjectName]
									WHERE	sdd.[StaticDataId] = sd.[StaticDataId]
										AND	mc.[modify_date] >= @LastPopulateTime
								)
							)
					 AND	[IsTestData] >= @TestDataOnly
					 AND	[IsTestData] = 0 
			END

		--! Process in sequence.
		DECLARE csr CURSOR LOCAL FAST_FORWARD READ_ONLY FOR 
			SELECT	
					  [SchemaName]
					, [TableName]
			FROM	@tables
			ORDER BY
					  [Precedence]
					, [SchemaName]
					, [TableName]

		OPEN csr
		FETCH NEXT FROM csr INTO @SchemaName, @TableName
		WHILE @@FETCH_STATUS = 0
			BEGIN
				SET @Sql = N'EXEC [Admin].[ApplyStaticData] @SchemaName = ' + @SchemaName + N' , @TableName = ' + @TableName + N', @PrintCommands = ' + CONVERT(NVARCHAR,@PrintCommands)  + N', @PrintCommandsOnly = ' + CONVERT(NVARCHAR,@PrintCommandsOnly)
				SET @Params = N''

				EXEC sp_executesql @stmt = @Sql, @Params = @Params

				FETCH NEXT FROM csr INTO @SchemaName, @TableName
			END
		CLOSE csr
		DEALLOCATE csr

		--! Capture successful run.
		EXEC [internal].[SetSetting]
			  @name = N'Populate'
			, @value = @Now

		--! If we started the transaction then commit otherwise leave to caller.			
		IF @EntryTranCount = 0 
			COMMIT

		--! Return success.
		RETURN 0
	ErrorExit:
		--! Raise error condition.
		RAISERROR('Procedure %s returned error code %d', 16, 0, @procedure, @ReturnCode)

	END TRY

	BEGIN CATCH
		IF @@trancount > 0 ROLLBACK TRANSACTION
		EXEC [internal].[catch_handler] @proc_id = @@PROCID
		RETURN 55555
	END CATCH
END
GO
PRINT N'Checking existing data against newly created constraints';


GO
USE [$(DatabaseName)];


GO
ALTER TABLE [admin].[StaticDataStatements] WITH CHECK CHECK CONSTRAINT [FKStaticDataStatementsStaticDataId];

ALTER TABLE [dbo].[BarCode] WITH CHECK CHECK CONSTRAINT [FKBarCodeProductId];

ALTER TABLE [dbo].[ProductCategory] WITH CHECK CHECK CONSTRAINT [FKProductCategoryProductId];

ALTER TABLE [dbo].[ProductCategory] WITH CHECK CHECK CONSTRAINT [FKProductCategoryCategoryId];

ALTER TABLE [dbo].[ProductSuperMarket] WITH CHECK CHECK CONSTRAINT [FKProductSuperMarketProductId];

ALTER TABLE [dbo].[ProductSuperMarket] WITH CHECK CHECK CONSTRAINT [FKProductSuperMarketSuperMarketId];

ALTER TABLE [dbo].[ShoppingList] WITH CHECK CHECK CONSTRAINT [FKShoppingListSuperMarketId];

ALTER TABLE [dbo].[ShoppingListProduct] WITH CHECK CHECK CONSTRAINT [FKShoppingListProductShoppingListId];

ALTER TABLE [dbo].[ShoppingListProduct] WITH CHECK CHECK CONSTRAINT [FKShoppingListProductProductId];


GO
PRINT N'Update complete.';


GO
